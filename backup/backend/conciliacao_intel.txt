"""
Concilia√ß√£o FIFO FLEX√çVEL - Aceita adiantamentos e pagamentos excedentes
Regras:
- Pagamentos podem ocorrer ANTES de compras (adiantamentos)
- Pagamentos excedentes geram "cr√©dito do cliente" (saldo devedor do fornecedor)
- FIFO puro √© aplicado nas NFs existentes
- Adiantamentos s√£o contabilizados separadamente
"""

from decimal import Decimal
from typing import List, Dict
from collections import deque
from sqlalchemy.orm import Session
from models import Fornecedor, LancamentoFornecedor


# Toler√¢ncia para "zerar" centavos residuais por arredondamento
EPS = Decimal("0.01")


def _d(x) -> Decimal:
    return x if isinstance(x, Decimal) else Decimal(str(x or "0"))


def _is_open(compra: LancamentoFornecedor) -> bool:
    return _d(compra.valor_saldo) > EPS


def conciliar_fornecedor_inteligente(db: Session, fornecedor_id: int) -> int:
    """
    Concilia um fornecedor aplicando TODOS os pagamentos via FIFO flex√≠vel.
    
    MUDAN√áA: Aceita pagamentos excedentes (adiantamentos) sem quebrar.
    
    COMPRA (cr√©dito): cria/representa uma NF (imut√°vel no valor_credito)
    PAGAMENTO (d√©bito): aplicado em cascata nas NFs mais antigas abertas
    ADIANTAMENTO: pagamento que n√£o encontra NF = cr√©dito do cliente
    
    Sa√≠das:
    - Atualiza em cada COMPRA:
        valor_pago_parcial, valor_saldo, status_pagamento
    - Retorna quantidade de NFs ainda pendentes (abertas)
    """

    # Compras (NFs) e pagamentos, ambos em ordem de data
    compras = db.query(LancamentoFornecedor).filter(
        LancamentoFornecedor.fornecedor_id == fornecedor_id,
        LancamentoFornecedor.tipo_operacao == "COMPRA"
    ).order_by(LancamentoFornecedor.data_lancamento).all()

    pagamentos = db.query(LancamentoFornecedor).filter(
        LancamentoFornecedor.fornecedor_id == fornecedor_id,
        LancamentoFornecedor.tipo_operacao == "PAGAMENTO"
    ).order_by(LancamentoFornecedor.data_lancamento).all()

    if not compras:
        print(f"   ‚ö†Ô∏è Nenhuma COMPRA encontrada; apenas pagamentos (adiantamentos)")
        return 0

    # Inicializa estado das compras (NF)
    for compra in compras:
        compra.valor_pago_parcial = Decimal("0")
        compra.valor_saldo = _d(compra.valor_credito)
        compra.status_pagamento = "PENDENTE"

    print(f"   üìã {len(compras)} NFs (COMPRA) encontradas")
    print(f"   üí≥ {len(pagamentos)} pagamentos (PAGAMENTO) encontrados")

    # Monta "event stream" (cr√©dito + d√©bito) em ordem temporal real
    # Importante: se houver mesma data, processa COMPRA antes de PAGAMENTO
    events = []
    for c in compras:
        events.append((c.data_lancamento, 0, c))  # 0 = compra primeiro
    for p in pagamentos:
        events.append((p.data_lancamento, 1, p))  # 1 = pagamento depois

    events.sort(key=lambda t: (t[0], t[1]))

    # Fila FIFO das NFs abertas
    fila = deque()
    
    # Controle de adiantamentos
    adiantamento_total = Decimal("0")

    # Processa eventos
    for _, tipo, obj in events:
        if tipo == 0:
            # COMPRA: entra na fila como NF aberta
            # Se houver adiantamento acumulado, aplica primeiro
            if adiantamento_total > 0 and _d(obj.valor_saldo) > 0:
                abate = min(adiantamento_total, _d(obj.valor_saldo))
                obj.valor_pago_parcial = abate
                obj.valor_saldo = _d(obj.valor_credito) - abate
                adiantamento_total -= abate
                
                if _d(obj.valor_saldo) <= EPS:
                    obj.valor_saldo = Decimal("0")
                    obj.status_pagamento = "PAGO"
                else:
                    obj.status_pagamento = "PARCIAL"
                    fila.append(obj)
                
                print(f"   üí∞ Adiantamento aplicado: R$ {abate:,.2f} na NF {obj.numero_nf or 'S/N'}")
            else:
                # Sem adiantamento, entra na fila normalmente
                if _d(obj.valor_saldo) > EPS:
                    fila.append(obj)
            continue

        # PAGAMENTO: aplica em cascata nas NFs abertas
        valor_pagamento = _d(obj.valor_debito)
        if valor_pagamento <= 0:
            continue

        restante = valor_pagamento

        # Garante que o topo da fila esteja realmente aberto (limpeza defensiva)
        while fila and not _is_open(fila[0]):
            fila.popleft()

        while restante > 0:
            if not fila:
                # MUDAN√áA: Ao inv√©s de lan√ßar erro, acumula como adiantamento
                adiantamento_total += restante
                print(f"   ‚ö° Adiantamento: R$ {restante:,.2f} (data={obj.data_lancamento.strftime('%Y-%m-%d')})")
                restante = Decimal("0")
                break

            nf_atual = fila[0]
            falta = _d(nf_atual.valor_saldo)

            abate = falta if falta < restante else restante

            # aplica abatimento
            nf_atual.valor_pago_parcial = _d(nf_atual.valor_pago_parcial) + abate
            nf_atual.valor_saldo = _d(nf_atual.valor_credito) - _d(nf_atual.valor_pago_parcial)

            # atualiza status
            if _d(nf_atual.valor_saldo) <= EPS:
                nf_atual.valor_saldo = Decimal("0")
                nf_atual.status_pagamento = "PAGO"
                fila.popleft()  # quitada sai da fila
            else:
                nf_atual.status_pagamento = "PARCIAL"

            restante -= abate

    db.commit()

    # Conta pendentes (NFs ainda abertas)
    pendentes = [c for c in compras if _d(c.valor_saldo) > EPS]
    
    if adiantamento_total > 0:
        print(f"   üí∞ Adiantamento total acumulado: R$ {adiantamento_total:,.2f}")
        print(f"   ‚ÑπÔ∏è  Fornecedor tem CR√âDITO (empresa pagou a mais)")
    
    print(f"   ‚úÖ {len(pendentes)} NFs com saldo pendente (FIFO flex√≠vel)")

    return len(pendentes)


def conciliar_todos_fornecedores_inteligente(db: Session, arquivo_id: int):
    """
    Concilia todos os fornecedores de um arquivo usando FIFO flex√≠vel.
    """
    fornecedores = db.query(Fornecedor).filter(
        Fornecedor.arquivo_origem_id == arquivo_id
    ).all()

    print(f"\nüîÑ Iniciando concilia√ß√£o FIFO flex√≠vel para {len(fornecedores)} fornecedores...")

    for forn in fornecedores:
        if _d(forn.total_credito) > 0 or _d(forn.total_debito) > 0:
            print(f"\nüîå {forn.codigo_conta} - {forn.nome_fornecedor[:40]}")
            try:
                pendentes = conciliar_fornecedor_inteligente(db, forn.id)
                forn.qtd_nfs_pendentes = pendentes
            except Exception as e:
                print(f"   ‚ùå Erro: {e}")
                import traceback
                traceback.print_exc()

    db.commit()
    print("\n‚úÖ Concilia√ß√£o FIFO flex√≠vel conclu√≠da!")